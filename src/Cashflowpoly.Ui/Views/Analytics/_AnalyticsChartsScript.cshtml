@model Cashflowpoly.Ui.Models.AnalyticsSearchViewModel
@using System.Text.Json

@if (Model.Result is not null)
{
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.6/dist/chart.umd.min.js"></script>
<script>
    (() => {
        const chartUnavailableMessage = @Html.Raw(JsonSerializer.Serialize(Context.T("analytics.chart.unavailable")));
        const chartNoDataMessage = @Html.Raw(JsonSerializer.Serialize(Context.T("analytics.chart.no_data")));
        try {
        const renderChartMessage = (canvas, message) => {
            if (!canvas) {
                return;
            }

            const chartCard = canvas.closest(".chart-card");
            if (!chartCard) {
                return;
            }

            canvas.style.display = "none";
            if (chartCard.querySelector(".chart-fallback-text")) {
                return;
            }

            const helperText = document.createElement("p");
            helperText.className = "chart-fallback-text mt-2 text-sm text-slate-500";
            helperText.textContent = message;
            chartCard.appendChild(helperText);
        };

        if (typeof Chart === "undefined") {
            document.querySelectorAll(".chart-card canvas").forEach((canvas) => {
                renderChartMessage(canvas, chartUnavailableMessage);
            });
            return;
        }

        const rawData = @Html.Raw(JsonSerializer.Serialize(Model.Result));
        const isPlayerDashboard = @((!Model.IsInstructor).ToString().ToLowerInvariant());
        const playerLabelPrefix = @Html.Raw(JsonSerializer.Serialize(Context.T("common.player")));
        const chartText = {
            event: @Html.Raw(JsonSerializer.Serialize(Context.T("analytics.chart.event"))),
            cashIn: @Html.Raw(JsonSerializer.Serialize(Context.T("analytics.chart.cash_in"))),
            cashOut: @Html.Raw(JsonSerializer.Serialize(Context.T("analytics.chart.cash_out"))),
            net: @Html.Raw(JsonSerializer.Serialize(Context.T("analytics.chart.net"))),
            summary: @Html.Raw(JsonSerializer.Serialize(Context.T("analytics.chart.summary"))),
            value: @Html.Raw(JsonSerializer.Serialize(Context.T("analytics.chart.value"))),
            points: @Html.Raw(JsonSerializer.Serialize(Context.T("analytics.chart.points"))),
            risk: @Html.Raw(JsonSerializer.Serialize(Context.T("analytics.chart.risk"))),
            donation: @Html.Raw(JsonSerializer.Serialize(Context.T("metric.donation"))),
            happiness: @Html.Raw(JsonSerializer.Serialize(Context.T("metric.happiness"))),
            needPoints: @Html.Raw(JsonSerializer.Serialize(Context.T("metric.need_points"))),
            needBonus: @Html.Raw(JsonSerializer.Serialize(Context.T("metric.need_bonus"))),
            donationPoints: @Html.Raw(JsonSerializer.Serialize(Context.T("metric.donation_points"))),
            goldPoints: @Html.Raw(JsonSerializer.Serialize(Context.T("metric.gold_points"))),
            pensionPoints: @Html.Raw(JsonSerializer.Serialize(Context.T("metric.pension_points"))),
            savingGoal: @Html.Raw(JsonSerializer.Serialize(Context.T("metric.saving_goal"))),
            missionPenalty: @Html.Raw(JsonSerializer.Serialize(Context.T("metric.mission_penalty"))),
            loanPenalty: @Html.Raw(JsonSerializer.Serialize(Context.T("metric.loan_penalty"))),
            loanUnpaid: @Html.Raw(JsonSerializer.Serialize(Context.T("metric.loan_unpaid"))),
            ordersCompleted: @Html.Raw(JsonSerializer.Serialize(Context.T("metric.orders_completed"))),
            inventoryIngredient: @Html.Raw(JsonSerializer.Serialize(Context.T("metric.inventory_ingredient"))),
            actionsUsed: @Html.Raw(JsonSerializer.Serialize(Context.T("metric.actions_used"))),
            primaryNeedCompliance: @Html.Raw(JsonSerializer.Serialize(Context.T("metric.primary_need_compliance"))),
            violations: @Html.Raw(JsonSerializer.Serialize(Context.T("metric.violations")))
        };

        const hasOwn = (obj, key) => Object.prototype.hasOwnProperty.call(obj, key);
        const toCamel = (key) => key.replace(/_([a-z])/g, (_, character) => character.toUpperCase());
        const toPascal = (key) => key.length === 0 ? key : `${key[0].toUpperCase()}${key.slice(1)}`;
        const getProp = (obj, snakeKey, explicitPascalKey = null) => {
            if (!obj || typeof obj !== "object") {
                return undefined;
            }

            if (hasOwn(obj, snakeKey)) {
                return obj[snakeKey];
            }

            const camelKey = toCamel(snakeKey);
            if (hasOwn(obj, camelKey)) {
                return obj[camelKey];
            }

            const pascalKey = explicitPascalKey ?? toPascal(camelKey);
            if (hasOwn(obj, pascalKey)) {
                return obj[pascalKey];
            }

            return undefined;
        };
        const toNumber = (value, fallback = 0) => {
            const numericValue = Number(value);
            return Number.isFinite(numericValue) ? numericValue : fallback;
        };
        const toBoolean = (value) => {
            if (typeof value === "boolean") {
                return value;
            }

            if (typeof value === "number") {
                return value !== 0;
            }

            if (typeof value === "string") {
                const normalizedValue = value.trim().toLowerCase();
                return normalizedValue === "true" || normalizedValue === "1";
            }

            return false;
        };

        const summarySource = getProp(rawData, "summary", "Summary") ?? {};
        const rawPlayers = getProp(rawData, "by_player", "ByPlayer");
        const players = Array.isArray(rawPlayers)
            ? rawPlayers.map((player) => ({
                player_id: `${getProp(player, "player_id", "PlayerId") ?? ""}`,
                cash_in_total: toNumber(getProp(player, "cash_in_total", "CashInTotal")),
                cash_out_total: toNumber(getProp(player, "cash_out_total", "CashOutTotal")),
                donation_total: toNumber(getProp(player, "donation_total", "DonationTotal")),
                gold_qty: toNumber(getProp(player, "gold_qty", "GoldQty")),
                happiness_points_total: toNumber(getProp(player, "happiness_points_total", "HappinessPointsTotal")),
                need_points_total: toNumber(getProp(player, "need_points_total", "NeedPointsTotal")),
                need_set_bonus_points: toNumber(getProp(player, "need_set_bonus_points", "NeedSetBonusPoints")),
                donation_points_total: toNumber(getProp(player, "donation_points_total", "DonationPointsTotal")),
                gold_points_total: toNumber(getProp(player, "gold_points_total", "GoldPointsTotal")),
                pension_points_total: toNumber(getProp(player, "pension_points_total", "PensionPointsTotal")),
                saving_goal_points_total: toNumber(getProp(player, "saving_goal_points_total", "SavingGoalPointsTotal")),
                mission_penalty_total: toNumber(getProp(player, "mission_penalty_total", "MissionPenaltyTotal")),
                loan_penalty_total: toNumber(getProp(player, "loan_penalty_total", "LoanPenaltyTotal")),
                has_unpaid_loan: toBoolean(getProp(player, "has_unpaid_loan", "HasUnpaidLoan")),
                orders_completed_count: toNumber(getProp(player, "orders_completed_count", "OrdersCompletedCount")),
                inventory_ingredient_total: toNumber(getProp(player, "inventory_ingredient_total", "InventoryIngredientTotal")),
                actions_used_total: toNumber(getProp(player, "actions_used_total", "ActionsUsedTotal")),
                compliance_primary_need_rate: toNumber(getProp(player, "compliance_primary_need_rate", "CompliancePrimaryNeedRate")),
                rules_violations_count: toNumber(getProp(player, "rules_violations_count", "RulesViolationsCount"))
            }))
            : [];
        const summary = {
            event_count: toNumber(getProp(summarySource, "event_count", "EventCount")),
            cash_in_total: toNumber(getProp(summarySource, "cash_in_total", "CashInTotal")),
            cash_out_total: toNumber(getProp(summarySource, "cash_out_total", "CashOutTotal")),
            cashflow_net_total: toNumber(getProp(summarySource, "cashflow_net_total", "CashflowNetTotal")),
            rules_violations_count: toNumber(getProp(summarySource, "rules_violations_count", "RulesViolationsCount"))
        };

        const metricPlayerSlots = [0, 1, 2, 3];
        const metricPlayerLabels = metricPlayerSlots.map((idx) => `${playerLabelPrefix} ${idx + 1}`);
        const isCompactViewport = window.matchMedia("(max-width: 768px)").matches;
        const chartFontSize = isCompactViewport ? 10 : 11;
        const slotMetricValue = (slotIndex, metricKey, config = {}) => {
            const p = players[slotIndex];
            if (!p) {
                return 0;
            }

            if (config.boolToNum) {
                return p[metricKey] ? 1 : 0;
            }

            const numericValue = p[metricKey] ?? 0;
            return config.multiply ? numericValue * config.multiply : numericValue;
        };

        const makeChart = (canvasId, type, labels, datasets, options = {}) => {
            const el = document.getElementById(canvasId);
            if (!el) {
                return;
            }

            if (!Array.isArray(labels) || labels.length === 0 || !Array.isArray(datasets) || datasets.length === 0) {
                renderChartMessage(el, chartNoDataMessage);
                return;
            }

            const hasDatasetValue = datasets.some((dataset) =>
                Array.isArray(dataset?.data) && dataset.data.some((value) => Number.isFinite(Number(value)))
            );
            if (!hasDatasetValue) {
                renderChartMessage(el, chartNoDataMessage);
                return;
            }

            try {
                const defaultOptions = {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            ticks: {
                                autoSkip: true,
                                maxRotation: isCompactViewport ? 0 : 35,
                                minRotation: 0,
                                font: { size: chartFontSize }
                            },
                            grid: {
                                display: !isCompactViewport
                            }
                        },
                        y: {
                            beginAtZero: true,
                            ticks: {
                                font: { size: chartFontSize }
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: datasets.length > 1,
                            position: isCompactViewport ? "bottom" : "top",
                            labels: {
                                usePointStyle: true,
                                pointStyle: "circle",
                                boxWidth: isCompactViewport ? 9 : 12,
                                boxHeight: isCompactViewport ? 9 : 12,
                                padding: isCompactViewport ? 10 : 14,
                                font: { size: chartFontSize }
                            }
                        }
                    }
                };
                const mergedOptions = {
                    ...defaultOptions,
                    ...options,
                    scales: {
                        ...defaultOptions.scales,
                        ...(options.scales ?? {}),
                        x: {
                            ...defaultOptions.scales.x,
                            ...(options.scales?.x ?? {}),
                            ticks: {
                                ...defaultOptions.scales.x.ticks,
                                ...(options.scales?.x?.ticks ?? {})
                            },
                            grid: {
                                ...defaultOptions.scales.x.grid,
                                ...(options.scales?.x?.grid ?? {})
                            }
                        },
                        y: {
                            ...defaultOptions.scales.y,
                            ...(options.scales?.y ?? {}),
                            ticks: {
                                ...defaultOptions.scales.y.ticks,
                                ...(options.scales?.y?.ticks ?? {})
                            }
                        }
                    },
                    plugins: {
                        ...defaultOptions.plugins,
                        ...(options.plugins ?? {}),
                        legend: {
                            ...defaultOptions.plugins.legend,
                            ...(options.plugins?.legend ?? {}),
                            labels: {
                                ...defaultOptions.plugins.legend.labels,
                                ...(options.plugins?.legend?.labels ?? {})
                            }
                        }
                    }
                };

                new Chart(el, {
                    type,
                    data: { labels, datasets },
                    options: mergedOptions
                });
            } catch (error) {
                console.error("Failed to render chart", canvasId, error);
                renderChartMessage(el, chartUnavailableMessage);
            }
        };

        if (isPlayerDashboard) {
            const me = players[0];
            if (!me) {
                document.querySelectorAll(".chart-card canvas").forEach((canvas) => {
                    renderChartMessage(canvas, chartNoDataMessage);
                });
                return;
            }

            const netCash = (me.cash_in_total ?? 0) - (me.cash_out_total ?? 0);

            makeChart("playerFinanceChart", "bar",
                [chartText.cashIn, chartText.cashOut, chartText.net, chartText.donation],
                [{
                    label: chartText.value,
                    data: [me.cash_in_total ?? 0, me.cash_out_total ?? 0, netCash, me.donation_total ?? 0],
                    backgroundColor: ["#2d7dd2", "#e95a4b", "#1ba784", "#f39c12"],
                    borderColor: ["#1f5aa0", "#b73f31", "#157f63", "#bf7608"],
                    borderWidth: 1.2
                }],
                {
                    plugins: { legend: { display: false } }
                });

            makeChart("playerPointsChart", "bar",
                [chartText.happiness, chartText.needPoints, chartText.needBonus, chartText.donationPoints, chartText.goldPoints, chartText.pensionPoints, chartText.savingGoal],
                [{
                    label: chartText.points,
                    data: [
                        me.happiness_points_total ?? 0,
                        me.need_points_total ?? 0,
                        me.need_set_bonus_points ?? 0,
                        me.donation_points_total ?? 0,
                        me.gold_points_total ?? 0,
                        me.pension_points_total ?? 0,
                        me.saving_goal_points_total ?? 0
                    ],
                    backgroundColor: "#3f74ff99",
                    borderColor: "#2d5ce0",
                    borderWidth: 1.2
                }],
                {
                    plugins: { legend: { display: false } }
                });

            makeChart("playerRiskChart", "bar",
                [chartText.missionPenalty, chartText.loanPenalty, chartText.loanUnpaid],
                [{
                    label: chartText.risk,
                    data: [me.mission_penalty_total ?? 0, me.loan_penalty_total ?? 0, me.has_unpaid_loan ? 1 : 0],
                    backgroundColor: ["#ef4e4e99", "#d1495b99", "#37415199"],
                    borderColor: ["#bf2e2e", "#a53344", "#1f2937"],
                    borderWidth: 1.2
                }],
                {
                    plugins: { legend: { display: false } }
                });

            makeChart("playerOperationsChart", "bar",
                [chartText.ordersCompleted, chartText.inventoryIngredient, chartText.actionsUsed, chartText.primaryNeedCompliance, chartText.violations],
                [{
                    label: chartText.value,
                    data: [
                        me.orders_completed_count ?? 0,
                        me.inventory_ingredient_total ?? 0,
                        me.actions_used_total ?? 0,
                        (me.compliance_primary_need_rate ?? 0) * 100,
                        me.rules_violations_count ?? 0
                    ],
                    backgroundColor: ["#2563eb99", "#0ea5e999", "#7c3aed99", "#16a34a99", "#dc262699"],
                    borderColor: ["#1d4ed8", "#0284c7", "#6d28d9", "#15803d", "#b91c1c"],
                    borderWidth: 1.2
                }],
                {
                    plugins: { legend: { display: false } }
                });

            return;
        }

        makeChart("summaryLineChart", "line",
            [chartText.event, chartText.cashIn, chartText.cashOut, chartText.net, chartText.violations],
            [{
                label: chartText.summary,
                data: [
                    summary.event_count,
                    summary.cash_in_total,
                    summary.cash_out_total,
                    summary.cashflow_net_total,
                    summary.rules_violations_count
                ],
                borderColor: "#e95a4b",
                backgroundColor: "rgba(233, 90, 75, 0.18)",
                tension: 0.32,
                pointRadius: 4,
                fill: true
            }]);

        if (players.length === 0) {
            renderChartMessage(document.getElementById("cashflowLineChart"), chartNoDataMessage);
        } else {
            makeChart("cashflowLineChart", "line", metricPlayerLabels, [
                {
                    label: chartText.cashIn,
                    data: metricPlayerSlots.map((slotIndex) => slotMetricValue(slotIndex, "cash_in_total")),
                    borderColor: "#1ba784",
                    backgroundColor: "rgba(27, 167, 132, 0.15)",
                    tension: 0.32,
                    pointRadius: 3
                },
                {
                    label: chartText.cashOut,
                    data: metricPlayerSlots.map((slotIndex) => slotMetricValue(slotIndex, "cash_out_total")),
                    borderColor: "#e95a4b",
                    backgroundColor: "rgba(233, 90, 75, 0.15)",
                    tension: 0.32,
                    pointRadius: 3
                },
                {
                    label: chartText.donation,
                    data: metricPlayerSlots.map((slotIndex) => slotMetricValue(slotIndex, "donation_total")),
                    borderColor: "#3f74ff",
                    backgroundColor: "rgba(63, 116, 255, 0.15)",
                    tension: 0.32,
                    pointRadius: 3
                }
            ]);
        }

        const metricCharts = [
            { id: "donationLineChart", key: "donation_total", color: "#18a8a0", label: chartText.donation },
            { id: "goldQtyLineChart", key: "gold_qty", color: "#f39c12", label: @Html.Raw(JsonSerializer.Serialize(Context.T("metric.gold_qty"))) },
            { id: "happinessLineChart", key: "happiness_points_total", color: "#ef4e4e", label: chartText.happiness },
            { id: "needPointsLineChart", key: "need_points_total", color: "#2a9d8f", label: chartText.needPoints },
            { id: "needBonusLineChart", key: "need_set_bonus_points", color: "#2fa56e", label: chartText.needBonus },
            { id: "donationPointsLineChart", key: "donation_points_total", color: "#2d7dd2", label: chartText.donationPoints },
            { id: "goldPointsLineChart", key: "gold_points_total", color: "#dd9f00", label: chartText.goldPoints },
            { id: "pensionPointsLineChart", key: "pension_points_total", color: "#ff7f50", label: chartText.pensionPoints },
            { id: "savingGoalLineChart", key: "saving_goal_points_total", color: "#00a6a6", label: chartText.savingGoal },
            { id: "missionPenaltyLineChart", key: "mission_penalty_total", color: "#c64f40", label: chartText.missionPenalty },
            { id: "loanPenaltyLineChart", key: "loan_penalty_total", color: "#d1495b", label: chartText.loanPenalty },
            { id: "loanUnpaidLineChart", key: "has_unpaid_loan", color: "#374151", boolToNum: true, label: chartText.loanUnpaid },
            { id: "ordersCompletedLineChart", key: "orders_completed_count", color: "#2563eb", label: chartText.ordersCompleted },
            { id: "inventoryIngredientLineChart", key: "inventory_ingredient_total", color: "#0ea5e9", label: chartText.inventoryIngredient },
            { id: "actionsUsedLineChart", key: "actions_used_total", color: "#7c3aed", label: chartText.actionsUsed },
            { id: "compliancePrimaryNeedLineChart", key: "compliance_primary_need_rate", color: "#16a34a", multiply: 100, label: chartText.primaryNeedCompliance },
            { id: "rulesViolationsLineChart", key: "rules_violations_count", color: "#dc2626", label: chartText.violations }
        ];

        metricCharts.forEach((metric) => {
            const values = metricPlayerSlots.map((slotIndex) =>
                slotMetricValue(slotIndex, metric.key, metric)
            );

            makeChart(metric.id, "line", metricPlayerLabels, [{
                label: metric.label,
                data: values,
                borderColor: metric.color,
                backgroundColor: `${metric.color}33`,
                tension: 0.32,
                pointRadius: 3,
                fill: true
            }]);
        });
        } catch (error) {
            console.error("Failed to initialize analytics charts", error);
            document.querySelectorAll(".chart-card canvas").forEach((canvas) => {
                const chartCard = canvas.closest(".chart-card");
                if (!chartCard || chartCard.querySelector(".chart-fallback-text")) {
                    return;
                }

                canvas.style.display = "none";
                const helperText = document.createElement("p");
                helperText.className = "chart-fallback-text mt-2 text-sm text-slate-500";
                helperText.textContent = chartUnavailableMessage;
                chartCard.appendChild(helperText);
            });
        }
    })();
</script>
}
