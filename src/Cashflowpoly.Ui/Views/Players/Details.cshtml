@* Fungsi file: Merender tampilan Razor untuk bagian Players/Details.cshtml beserta interaksi presentasinya. *@
@using System.Globalization
@using System.Text
@using System.Text.Json
@using Microsoft.AspNetCore.Http
@using Cashflowpoly.Ui.Infrastructure
@model Cashflowpoly.Ui.Models.PlayerDetailViewModel

@{
    ViewData["Title"] = Context.T("players.detail_title");

    var activeLanguage = UiText.NormalizeLanguage(Context.Session.GetString(AuthConstants.SessionLanguageKey));
    var isEnglish = string.Equals(activeLanguage, AuthConstants.LanguageEn, StringComparison.OrdinalIgnoreCase);
    string L(string id, string en) => isEnglish ? en : id;

    static string FormatJsonLeafValue(JsonElement element)
    {
        return element.ValueKind switch
        {
            JsonValueKind.String => element.GetString() ?? string.Empty,
            JsonValueKind.True => "true",
            JsonValueKind.False => "false",
            JsonValueKind.Number => element.GetRawText(),
            JsonValueKind.Null => "null",
            _ => element.GetRawText()
        };
    }

    static List<(string Path, string Value)> FlattenJsonLeaves(JsonElement? root)
    {
        var rows = new List<(string Path, string Value)>();
        if (!root.HasValue)
        {
            return rows;
        }

        static void Visit(JsonElement element, string path, List<(string Path, string Value)> output)
        {
            switch (element.ValueKind)
            {
                case JsonValueKind.Object:
                {
                    var hasProperty = false;
                    foreach (var property in element.EnumerateObject())
                    {
                        hasProperty = true;
                        var nextPath = string.IsNullOrWhiteSpace(path) ? property.Name : $"{path}.{property.Name}";
                        Visit(property.Value, nextPath, output);
                    }

                    if (!hasProperty && !string.IsNullOrWhiteSpace(path))
                    {
                        output.Add((path, "{}"));
                    }

                    break;
                }
                case JsonValueKind.Array:
                {
                    var index = 0;
                    foreach (var item in element.EnumerateArray())
                    {
                        Visit(item, $"{path}[{index}]", output);
                        index += 1;
                    }

                    if (index == 0 && !string.IsNullOrWhiteSpace(path))
                    {
                        output.Add((path, "[]"));
                    }

                    break;
                }
                case JsonValueKind.String:
                case JsonValueKind.True:
                case JsonValueKind.False:
                case JsonValueKind.Number:
                case JsonValueKind.Null:
                    output.Add((string.IsNullOrWhiteSpace(path) ? "value" : path, FormatJsonLeafValue(element)));
                    break;
                default:
                    output.Add((string.IsNullOrWhiteSpace(path) ? "value" : path, element.ToString()));
                    break;
            }
        }

        Visit(root.Value, string.Empty, rows);
        return rows;
    }

    static List<(string GroupKey, List<(string Path, string Value)> Rows)> BuildMetricGroups(JsonElement? root)
    {
        var groups = new List<(string GroupKey, List<(string Path, string Value)> Rows)>();
        if (!root.HasValue || root.Value.ValueKind != JsonValueKind.Object)
        {
            return groups;
        }

        var scalarRows = new List<(string Path, string Value)>();
        foreach (var property in root.Value.EnumerateObject())
        {
            if (property.Value.ValueKind == JsonValueKind.Object || property.Value.ValueKind == JsonValueKind.Array)
            {
                var rows = FlattenJsonLeaves(property.Value);
                if (rows.Count == 0)
                {
                    rows.Add(("value", FormatJsonLeafValue(property.Value)));
                }

                groups.Add((property.Name, rows));
                continue;
            }

            scalarRows.Add((property.Name, FormatJsonLeafValue(property.Value)));
        }

        if (scalarRows.Count > 0)
        {
            groups.Insert(0, ("summary", scalarRows));
        }

        return groups;
    }

    static Dictionary<string, JsonElement> BuildMetricGroupElements(JsonElement? root)
    {
        var groups = new Dictionary<string, JsonElement>(StringComparer.OrdinalIgnoreCase);
        if (!root.HasValue || root.Value.ValueKind != JsonValueKind.Object)
        {
            return groups;
        }

        foreach (var property in root.Value.EnumerateObject())
        {
            groups[property.Name] = property.Value.Clone();
        }

        return groups;
    }

    static bool TryGetNumericValue(JsonElement element, out double value)
    {
        switch (element.ValueKind)
        {
            case JsonValueKind.Number:
                return element.TryGetDouble(out value);
            case JsonValueKind.String:
                if (double.TryParse(element.GetString(), out var parsed))
                {
                    value = parsed;
                    return true;
                }

                break;
        }

        value = 0;
        return false;
    }

    static string HumanizeMetricKey(string key)
    {
        if (string.IsNullOrWhiteSpace(key))
        {
            return "Metric";
        }

        var text = key.Replace('_', ' ').Trim();
        if (text.Length == 0)
        {
            return "Metric";
        }

        return char.ToUpperInvariant(text[0]) + text[1..];
    }

    string FormatMetricPathLabel(string rawPath)
    {
        if (string.IsNullOrWhiteSpace(rawPath))
        {
            return L("Metrik", "Metric");
        }

        var tokens = new List<string>();
        var buffer = new StringBuilder();

        void FlushBuffer()
        {
            if (buffer.Length == 0)
            {
                return;
            }

            tokens.Add(HumanizeMetricKey(buffer.ToString()));
            buffer.Clear();
        }

        for (var index = 0; index < rawPath.Length; index++)
        {
            var current = rawPath[index];
            if (current == '.')
            {
                FlushBuffer();
                continue;
            }

            if (current == '[')
            {
                FlushBuffer();

                var closeIndex = rawPath.IndexOf(']', index);
                if (closeIndex > index)
                {
                    var indexToken = rawPath.Substring(index + 1, closeIndex - index - 1);
                    if (int.TryParse(indexToken, out var parsedIndex))
                    {
                        tokens.Add($"{L("Item", "Item")} {parsedIndex + 1}");
                    }
                    else if (!string.IsNullOrWhiteSpace(indexToken))
                    {
                        tokens.Add($"{L("Item", "Item")} {indexToken}");
                    }

                    index = closeIndex;
                    continue;
                }
            }

            buffer.Append(current);
        }

        FlushBuffer();

        var displayTokens = tokens
            .Where(token => !string.IsNullOrWhiteSpace(token))
            .ToList();

        if (displayTokens.Count == 0)
        {
            return HumanizeMetricKey(rawPath);
        }

        return string.Join(" - ", displayTokens);
    }

    bool TryParseMetricNumber(string rawValue, out double numericValue)
    {
        if (string.IsNullOrWhiteSpace(rawValue))
        {
            numericValue = 0;
            return false;
        }

        if (string.Equals(rawValue, "true", StringComparison.OrdinalIgnoreCase))
        {
            numericValue = 1;
            return true;
        }

        if (string.Equals(rawValue, "false", StringComparison.OrdinalIgnoreCase))
        {
            numericValue = 0;
            return true;
        }

        if (double.TryParse(rawValue, NumberStyles.Float, CultureInfo.InvariantCulture, out numericValue))
        {
            return true;
        }

        if (double.TryParse(rawValue, NumberStyles.Float, CultureInfo.CurrentCulture, out numericValue))
        {
            return true;
        }

        numericValue = 0;
        return false;
    }

    static bool IsPreferredCombinedSummaryPath(string path)
    {
        if (string.IsNullOrWhiteSpace(path))
        {
            return false;
        }

        // Keep only compact scalar-like paths in the primary summary.
        return !path.Contains('[') && !path.Contains('.');
    }

    static bool IsFallbackCombinedSummaryPath(string path)
    {
        if (string.IsNullOrWhiteSpace(path))
        {
            return false;
        }

        // Fallback: allow nested objects but still exclude indexed array rows
        // because those are already represented in dedicated charts.
        return !path.Contains('[');
    }

    (string Title, string Json)? BuildMergedRowChart(
        string domainTitle,
        IEnumerable<(string Path, string Value)> rows)
    {
        var numericRows = rows
            .Where(row => !string.IsNullOrWhiteSpace(row.Path))
            .Where(row => TryParseMetricNumber(row.Value, out _))
            .ToList();

        var summaryRows = numericRows
            .Where(row => IsPreferredCombinedSummaryPath(row.Path))
            .ToList();
        if (summaryRows.Count == 0)
        {
            summaryRows = numericRows
                .Where(row => IsFallbackCombinedSummaryPath(row.Path))
                .ToList();
        }

        if (summaryRows.Count == 0)
        {
            return null;
        }

        var points = new List<(string Label, double Value)>();
        var labelUsage = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);
        foreach (var row in summaryRows)
        {
            if (TryParseMetricNumber(row.Value, out var value))
            {
                var baseLabel = FormatMetricPathLabel(row.Path).Trim();
                if (string.IsNullOrWhiteSpace(baseLabel))
                {
                    baseLabel = L("Metrik", "Metric");
                }

                if (!labelUsage.TryGetValue(baseLabel, out var usageCount))
                {
                    labelUsage[baseLabel] = 1;
                    points.Add((baseLabel, value));
                    continue;
                }

                usageCount += 1;
                labelUsage[baseLabel] = usageCount;
                points.Add(($"{baseLabel} ({usageCount})", value));
            }
        }

        const int maxPoints = 36;
        if (points.Count > maxPoints)
        {
            points = points.Take(maxPoints).ToList();
        }

        var payload = new
        {
            chartType = "bar",
            labels = points.Select(point => point.Label).ToList(),
            series = new[]
            {
                new
                {
                    name = L("Nilai", "Value"),
                    values = points.Select(point => (double?)point.Value).ToList()
                }
            }
        };

        return ($"{domainTitle}: {L("Ringkasan Gabungan", "Combined Snapshot")}", JsonSerializer.Serialize(payload));
    }

    static List<(string Path, string Value)> MergeUniqueRows(params IEnumerable<(string Path, string Value)>[] rowSets)
    {
        var result = new List<(string Path, string Value)>();
        var seen = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
        foreach (var rowSet in rowSets)
        {
            foreach (var row in rowSet)
            {
                if (string.IsNullOrWhiteSpace(row.Path))
                {
                    continue;
                }

                if (seen.Add(row.Path))
                {
                    result.Add(row);
                }
            }
        }

        return result;
    }

    static List<(string Path, string Value)> GetGroupRows(
        Dictionary<string, List<(string Path, string Value)>> source,
        params string[] keys)
    {
        var rows = new List<(string Path, string Value)>();
        foreach (var key in keys)
        {
            if (!source.TryGetValue(key, out var groupRows))
            {
                continue;
            }

            rows.AddRange(groupRows);
        }

        return rows;
    }

    static List<(string Path, string Value)> FilterRowsByKeywords(
        IEnumerable<(string Path, string Value)> rows,
        params string[] keywords)
    {
        return rows
            .Where(row => keywords.Any(keyword => row.Path.Contains(keyword, StringComparison.OrdinalIgnoreCase)))
            .ToList();
    }

    static List<(string Title, string Json)> MergeUniqueCharts(params IEnumerable<(string Title, string Json)>[] chartSets)
    {
        var result = new List<(string Title, string Json)>();
        var seen = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
        foreach (var chartSet in chartSets)
        {
            foreach (var chart in chartSet)
            {
                if (string.IsNullOrWhiteSpace(chart.Title))
                {
                    continue;
                }

                if (seen.Add(chart.Title))
                {
                    result.Add(chart);
                }
            }
        }

        return result;
    }

    static List<(string Title, string Json)> FilterChartsByKeywords(
        IEnumerable<(string Title, string Json)> charts,
        params string[] keywords)
    {
        if (keywords is null || keywords.Length == 0)
        {
            return charts.ToList();
        }

        return charts
            .Where(chart => keywords.Any(keyword => chart.Title.Contains(keyword, StringComparison.OrdinalIgnoreCase)))
            .ToList();
    }

    List<(string Title, string Json)> BuildSectionCharts(
        string domainTitle,
        List<(string Path, string Value)> rows,
        List<(string Title, string Json)> baseCharts,
        int maxCharts = 4)
    {
        var chartCandidates = new List<(string Title, string Json)>();
        var mergedChart = BuildMergedRowChart(domainTitle, rows);
        if (mergedChart.HasValue)
        {
            chartCandidates.Add(mergedChart.Value);
        }

        chartCandidates.AddRange(baseCharts);
        var charts = MergeUniqueCharts(chartCandidates);
        if (charts.Count > maxCharts)
        {
            return charts.Take(maxCharts).ToList();
        }

        return charts;
    }

    static List<(string Title, string Json)> GetGroupCharts(
        Dictionary<string, List<(string Title, string Json)>> source,
        params string[] keys)
    {
        var charts = new List<(string Title, string Json)>();
        foreach (var key in keys)
        {
            if (!source.TryGetValue(key, out var groupCharts))
            {
                continue;
            }

            charts.AddRange(groupCharts);
        }

        return charts;
    }

    static List<(string Title, string Json)> BuildLineChartsForGroup(string groupKey, JsonElement groupElement)
    {
        var charts = new List<(string Title, string Json)>();
        if (groupElement.ValueKind != JsonValueKind.Object)
        {
            return charts;
        }

        foreach (var property in groupElement.EnumerateObject())
        {
            var chart = BuildLineChartPayload($"{groupKey}.{property.Name}", property.Value);
            if (chart.HasValue)
            {
                charts.Add(chart.Value);
            }
        }

        return charts;
    }

    static (string Title, string Json)? BuildLineChartPayload(string path, JsonElement element)
    {
        var labels = new List<string>();
        var series = new Dictionary<string, List<double?>>(StringComparer.OrdinalIgnoreCase);

        void AppendLabel(string label)
        {
            labels.Add(label);
            foreach (var values in series.Values)
            {
                values.Add(null);
            }
        }

        void SetSeriesValue(string seriesName, double value)
        {
            if (!series.TryGetValue(seriesName, out var values))
            {
                values = Enumerable.Repeat<double?>(null, labels.Count).ToList();
                series[seriesName] = values;
            }

            values[labels.Count - 1] = value;
        }

        if (element.ValueKind == JsonValueKind.Array)
        {
            var items = element.EnumerateArray().ToList();
            if (items.Count == 0)
            {
                return null;
            }

            if (items.All(item => TryGetNumericValue(item, out _)))
            {
                for (var index = 0; index < items.Count; index++)
                {
                    AppendLabel((index + 1).ToString());
                    if (TryGetNumericValue(items[index], out var numericValue))
                    {
                        SetSeriesValue("value", numericValue);
                    }
                }
            }
            else if (items.All(item => item.ValueKind == JsonValueKind.Object))
            {
                var xAxisCandidates = new[]
                {
                    "turn_number",
                    "day_index",
                    "friday_index",
                    "order_index",
                    "card_index",
                    "goal_index",
                    "sequence_number",
                    "index"
                };

                string? xKey = null;
                foreach (var candidate in xAxisCandidates)
                {
                    if (items.Any(item => item.TryGetProperty(candidate, out _)))
                    {
                        xKey = candidate;
                        break;
                    }
                }

                if (xKey is null)
                {
                    xKey = items
                        .SelectMany(item => item.EnumerateObject().Select(prop => prop.Name))
                        .FirstOrDefault(name =>
                            name.EndsWith("_number", StringComparison.OrdinalIgnoreCase) ||
                            name.EndsWith("_index", StringComparison.OrdinalIgnoreCase));
                }

                for (var index = 0; index < items.Count; index++)
                {
                    var item = items[index];
                    var label = (index + 1).ToString();
                    var rowValues = new Dictionary<string, double>(StringComparer.OrdinalIgnoreCase);
                    foreach (var property in item.EnumerateObject())
                    {
                        if (!string.IsNullOrWhiteSpace(xKey) &&
                            property.Name.Equals(xKey, StringComparison.OrdinalIgnoreCase))
                        {
                            label = FormatJsonLeafValue(property.Value);
                            continue;
                        }

                        if (TryGetNumericValue(property.Value, out var numericValue))
                        {
                            rowValues[property.Name] = numericValue;
                            continue;
                        }

                        if (property.Value.ValueKind == JsonValueKind.Array &&
                            property.Name.Equals("actions", StringComparison.OrdinalIgnoreCase))
                        {
                            rowValues["actions_count"] = property.Value.GetArrayLength();
                        }
                    }

                    AppendLabel(label);
                    foreach (var rowValue in rowValues)
                    {
                        SetSeriesValue(rowValue.Key, rowValue.Value);
                    }
                }
            }
            else
            {
                return null;
            }
        }
        else if (element.ValueKind == JsonValueKind.Object &&
                 path.Contains("_per_", StringComparison.OrdinalIgnoreCase))
        {
            foreach (var property in element.EnumerateObject())
            {
                if (!TryGetNumericValue(property.Value, out var numericValue))
                {
                    continue;
                }

                AppendLabel(HumanizeMetricKey(property.Name));
                SetSeriesValue("value", numericValue);
            }
        }
        else
        {
            return null;
        }

        var activeSeries = series
            .Where(item => item.Value.Any(value => value.HasValue))
            .Select(item => new
            {
                name = HumanizeMetricKey(item.Key),
                values = item.Value
            })
            .ToList();
        if (labels.Count == 0 || activeSeries.Count == 0)
        {
            return null;
        }

        var pathParts = path.Split('.', StringSplitOptions.RemoveEmptyEntries);
        var groupLabel = pathParts.Length > 0 ? HumanizeMetricKey(pathParts[0]) : "Series";
        var metricLabel = pathParts.Length > 1 ? HumanizeMetricKey(pathParts[^1]) : HumanizeMetricKey(path);
        var title = $"{groupLabel}: {metricLabel}";
        var payload = new
        {
            labels,
            series = activeSeries
        };

        return (title, JsonSerializer.Serialize(payload));
    }

    var rawGroups = BuildMetricGroups(Model.GameplayRaw);
    var derivedGroups = BuildMetricGroups(Model.GameplayDerived);
    var rawGroupMap = rawGroups.ToDictionary(item => item.GroupKey, item => item.Rows, StringComparer.OrdinalIgnoreCase);
    var derivedGroupMap = derivedGroups.ToDictionary(item => item.GroupKey, item => item.Rows, StringComparer.OrdinalIgnoreCase);
    var rawGroupElementMap = BuildMetricGroupElements(Model.GameplayRaw);
    var derivedGroupElementMap = BuildMetricGroupElements(Model.GameplayDerived);
    var rawGroupChartsMap = rawGroupElementMap.ToDictionary(
        item => item.Key,
        item => BuildLineChartsForGroup(item.Key, item.Value),
        StringComparer.OrdinalIgnoreCase);
    var derivedGroupChartsMap = derivedGroupElementMap.ToDictionary(
        item => item.Key,
        item => BuildLineChartsForGroup(item.Key, item.Value),
        StringComparer.OrdinalIgnoreCase);

    var mappedRawKeys = new HashSet<string>(
        new[] { "coins", "ingredients", "meal_orders", "needs", "donations", "gold", "pension", "life_risk", "financial_goals", "actions", "turns" },
        StringComparer.OrdinalIgnoreCase);
    var rawFallbackKeys = rawGroupMap.Keys.Where(key => !mappedRawKeys.Contains(key)).ToArray();

    var part11Rows = MergeUniqueRows(
        GetGroupRows(rawGroupMap, "turns"),
        GetGroupRows(rawGroupMap, rawFallbackKeys));
    var part11Charts = MergeUniqueCharts(
        GetGroupCharts(rawGroupChartsMap, "turns"),
        GetGroupCharts(rawGroupChartsMap, rawFallbackKeys));

    var rawSections = new List<(string Title, string Description, List<(string Title, string Json)> Charts)>
    {
        (
            L("Variabel Koin dan Finansial", "Coin and Financial Variables"),
            L("Modal awal, arus kas, donasi, tabungan, dan saldo akhir.", "Starting capital, cashflow, donations, savings, and end balance."),
            BuildSectionCharts(
                L("Variabel Koin dan Finansial", "Coin and Financial Variables"),
                GetGroupRows(rawGroupMap, "coins"),
                GetGroupCharts(rawGroupChartsMap, "coins"),
                maxCharts: 5)),
        (
            L("Variabel Kartu Bahan", "Ingredient Card Variables"),
            L("Perolehan, stok, penggunaan, dan pemborosan bahan.", "Ingredient acquisition, stock, usage, and waste."),
            BuildSectionCharts(
                L("Variabel Kartu Bahan", "Ingredient Card Variables"),
                GetGroupRows(rawGroupMap, "ingredients"),
                GetGroupCharts(rawGroupChartsMap, "ingredients"),
                maxCharts: 5)),
        (
            L("Variabel Pesanan Makanan", "Meal Order Variables"),
            L("Jumlah pesanan, pendapatan pesanan, dan keputusan melewati pesanan.", "Order count, order income, and pass decisions."),
            BuildSectionCharts(
                L("Variabel Pesanan Makanan", "Meal Order Variables"),
                GetGroupRows(rawGroupMap, "meal_orders"),
                GetGroupCharts(rawGroupChartsMap, "meal_orders"),
                maxCharts: 5)),
        (
            L("Variabel Kartu Kebutuhan", "Need Card Variables"),
            L("Kepemilikan kebutuhan primer-sekunder-tersier dan status misi koleksi.", "Primary-secondary-tertiary needs ownership and collection mission status."),
            BuildSectionCharts(
                L("Variabel Kartu Kebutuhan", "Need Card Variables"),
                GetGroupRows(rawGroupMap, "needs"),
                GetGroupCharts(rawGroupChartsMap, "needs"),
                maxCharts: 5)),
        (
            L("Variabel Donasi", "Donation Variables"),
            L("Nominal donasi, ranking donasi, dan poin donasi.", "Donation amount, donation rank, and donation points."),
            BuildSectionCharts(
                L("Variabel Donasi", "Donation Variables"),
                GetGroupRows(rawGroupMap, "donations"),
                GetGroupCharts(rawGroupChartsMap, "donations"),
                maxCharts: 5)),
        (
            L("Variabel Investasi Emas", "Gold Investment Variables"),
            L("Pembelian, penjualan, posisi akhir, dan arus kas emas.", "Gold buy/sell, ending position, and gold cashflow."),
            BuildSectionCharts(
                L("Variabel Investasi Emas", "Gold Investment Variables"),
                GetGroupRows(rawGroupMap, "gold"),
                GetGroupCharts(rawGroupChartsMap, "gold"),
                maxCharts: 5)),
        (
            L("Variabel Dana Pensiun", "Pension Fund Variables"),
            L("Komponen dana pensiun akhir dan peringkat poin pensiun.", "End-game pension components and pension ranking points."),
            BuildSectionCharts(
                L("Variabel Dana Pensiun", "Pension Fund Variables"),
                GetGroupRows(rawGroupMap, "pension"),
                GetGroupCharts(rawGroupChartsMap, "pension"),
                maxCharts: 5)),
        (
            L("Variabel Risiko Hidup", "Life Risk Variables"),
            L("Frekuensi risiko, biaya risiko, dan mitigasi asuransi.", "Risk frequency, risk costs, and insurance mitigation."),
            BuildSectionCharts(
                L("Variabel Risiko Hidup", "Life Risk Variables"),
                GetGroupRows(rawGroupMap, "life_risk"),
                GetGroupCharts(rawGroupChartsMap, "life_risk"),
                maxCharts: 5)),
        (
            L("Variabel Target Finansial", "Financial Goal Variables"),
            L("Progres target finansial, pinjaman, dan status pelunasan.", "Financial goal progress, loans, and repayment status."),
            BuildSectionCharts(
                L("Variabel Target Finansial", "Financial Goal Variables"),
                GetGroupRows(rawGroupMap, "financial_goals"),
                GetGroupCharts(rawGroupChartsMap, "financial_goals"),
                maxCharts: 5)),
        (
            L("Variabel Penggunaan Token Aksi", "Action Token Usage Variables"),
            L("Distribusi aksi per giliran, repetisi aksi, dan aksi terlewati.", "Per-turn action distribution, repetitions, and skipped actions."),
            BuildSectionCharts(
                L("Variabel Penggunaan Token Aksi", "Action Token Usage Variables"),
                GetGroupRows(rawGroupMap, "actions"),
                GetGroupCharts(rawGroupChartsMap, "actions"),
                maxCharts: 5)),
        (
            L("Variabel Progres Giliran", "Turn-by-Turn Progression Variables"),
            L("Perkembangan ekonomi dari awal sampai akhir permainan.", "Economic progression from start to end of the game."),
            BuildSectionCharts(
                L("Variabel Progres Giliran", "Turn-by-Turn Progression Variables"),
                part11Rows,
                part11Charts,
                maxCharts: 5))
    };

    var derivedSummaryRows = GetGroupRows(derivedGroupMap, "summary");

    var financialDerivedRows = MergeUniqueRows(
        FilterRowsByKeywords(
            derivedSummaryRows,
            "net_worth",
            "income_diversification",
            "expense_management",
            "business_profit",
            "business_efficiency",
            "gold_roi",
            "growth_pattern"),
        GetGroupRows(derivedGroupMap, "expense_management_components"));

    var strategicDerivedRows = MergeUniqueRows(
        FilterRowsByKeywords(
            derivedSummaryRows,
            "risk_appetite",
            "debt_leverage",
            "debt_ratio",
            "loan_repayment",
            "goal_setting_ambition",
            "risk_exposure",
            "risk_mitigation"),
        GetGroupRows(derivedGroupMap, "risk_appetite_components"));

    var behaviorDerivedRows = FilterRowsByKeywords(
        derivedSummaryRows,
        "action_efficiency",
        "meal_order_success",
        "planning_horizon",
        "donation_aggressiveness",
        "donation_stability");

    var flourishingDerivedRows = MergeUniqueRows(
        FilterRowsByKeywords(
            derivedSummaryRows,
            "fulfillment_diversity",
            "donation_commitment",
            "mission_achievement"),
        GetGroupRows(derivedGroupMap, "happiness_portfolio"));

    var mappedDerivedPaths = new HashSet<string>(
        financialDerivedRows
            .Concat(strategicDerivedRows)
            .Concat(behaviorDerivedRows)
            .Concat(flourishingDerivedRows)
            .Select(row => row.Path),
        StringComparer.OrdinalIgnoreCase);
    var fallbackDerivedRows = derivedSummaryRows.Where(row => !mappedDerivedPaths.Contains(row.Path)).ToList();
    if (fallbackDerivedRows.Count > 0)
    {
        behaviorDerivedRows = MergeUniqueRows(behaviorDerivedRows, fallbackDerivedRows);
    }

    var derivedSections = new List<(string Title, string Description, List<(string Title, string Json)> Charts)>
    {
        (
            L("Metrik Performa Finansial", "Financial Performance Metrics"),
            L("Indeks kekayaan, diversifikasi pendapatan, efisiensi pengeluaran, dan margin laba.", "Net worth index, income diversification, spending efficiency, and profit margin."),
            BuildSectionCharts(
                L("Metrik Performa Finansial", "Financial Performance Metrics"),
                financialDerivedRows,
                FilterChartsByKeywords(
                    GetGroupCharts(derivedGroupChartsMap, "summary", "expense_management_components"),
                    "net", "income", "expense", "business", "gold", "growth"),
                maxCharts: 4)),
        (
            L("Metrik Keputusan Strategis", "Strategic Decision Metrics"),
            L("Selera risiko, leverage utang, dan ambisi target finansial.", "Risk appetite, debt leverage, and financial goal ambition."),
            BuildSectionCharts(
                L("Metrik Keputusan Strategis", "Strategic Decision Metrics"),
                strategicDerivedRows,
                FilterChartsByKeywords(
                    GetGroupCharts(derivedGroupChartsMap, "summary", "risk_appetite_components"),
                    "risk", "debt", "goal", "loan"),
                maxCharts: 4)),
        (
            L("Metrik Perilaku Pemain", "Player Behavior Metrics"),
            L("Efisiensi aksi, keberhasilan pesanan, dan orientasi perencanaan.", "Action efficiency, order success, and planning orientation."),
            BuildSectionCharts(
                L("Metrik Perilaku Pemain", "Player Behavior Metrics"),
                behaviorDerivedRows,
                FilterChartsByKeywords(
                    GetGroupCharts(derivedGroupChartsMap, "summary"),
                    "action", "meal", "order", "planning", "donation"),
                maxCharts: 4)),
        (
            L("Metrik Flourishing", "Flourishing-Related Metrics"),
            L("Keberagaman pemenuhan, komitmen donasi, dan komposisi portofolio kebahagiaan.", "Fulfillment diversity, donation commitment, and happiness portfolio composition."),
            BuildSectionCharts(
                L("Metrik Flourishing", "Flourishing-Related Metrics"),
                flourishingDerivedRows,
                FilterChartsByKeywords(
                    GetGroupCharts(derivedGroupChartsMap, "summary", "happiness_portfolio"),
                    "fulfillment", "mission", "happiness", "donation"),
                maxCharts: 4))
    };

    var hasGameplayData = Model.GameplayDerived.HasValue || Model.GameplayRaw.HasValue;
}

<section class="section-shell player-detail-overhaul">
    <div class="player-detail-hero">
        <p class="eyebrow text-emerald-700">@Context.T("players.analytics_title")</p>
        <h1 class="headline">@Context.T("players.detail_title")</h1>
        @if (!string.IsNullOrWhiteSpace(Model.PlayerDisplayName))
        {
            <p class="player-detail-name">@Model.PlayerDisplayName</p>
        }
        <div class="player-detail-meta">
            <span class="player-detail-meta__item player-detail-meta__item--mono">@Model.PlayerId</span>
            @if (Model.GameplayComputedAt.HasValue)
            {
                <span class="player-detail-meta__item">@Context.T("common.computed"): @Model.GameplayComputedAt.Value.ToString("dd/MM/yyyy HH:mm")</span>
            }
        </div>
    </div>

    @if (!string.IsNullOrWhiteSpace(Model.ErrorMessage))
    {
        <div class="mt-4 alert alert-error" aria-live="polite">
            @Model.ErrorMessage
        </div>
    }

    @if (!string.IsNullOrWhiteSpace(Model.GameplayErrorMessage))
    {
        <div class="mt-4 alert alert-warning" aria-live="polite">
            @Model.GameplayErrorMessage
        </div>
    }

    @if (!hasGameplayData)
    {
        <div class="mt-6 alert alert-info" aria-live="polite">
            @Context.T("state.no_player_data")
        </div>
    }
    else
    {
        <div id="physical-variables" class="players-fusion-metrics player-detail-section">
            <div class="players-fusion-head">
                <div class="page-intro-main">
                    <p class="eyebrow">@Context.T("gameplay.raw")</p>
                    <h2 class="headline text-xl">@L("Variabel Permainan Fisik", "Physical Gameplay Variables")</h2>
                    <p class="subhead text-sm">@L("Semua domain variabel mentah divisualkan sebagai diagram. Ringkasan gabungan tampil sebagai batang, metrik sisanya tetap dalam garis agar pola tetap mudah dibaca.", "All raw-variable domains are visualized as charts. Combined snapshots are shown as bars, while the remaining metrics stay as lines for readability.")</p>
                </div>
            </div>

            <div class="metric-domain-layout mt-6">
                @foreach (var domain in rawSections)
                {
                    <article class="metric-domain-card metric-domain-card-flat">
                        <div class="metric-domain-heading">
                            <h3>@domain.Title</h3>
                            <span class="metric-domain-count">@domain.Charts.Count @L("diagram", "charts")</span>
                        </div>
                        <p class="metric-domain-intro">@domain.Description</p>
                        @if (domain.Charts.Count == 0)
                        {
                            <p class="metric-domain-empty">@L("Belum ada titik numerik untuk divisualkan pada domain ini.", "No numeric points are currently available for this domain.")</p>
                        }
                        else
                        {
                            var summaryChart = domain.Charts.FirstOrDefault(chart =>
                                chart.Title.Contains("Ringkasan Gabungan", StringComparison.OrdinalIgnoreCase) ||
                                chart.Title.Contains("Combined Snapshot", StringComparison.OrdinalIgnoreCase));
                            var hasSummaryChart = !string.IsNullOrWhiteSpace(summaryChart.Title);
                            var detailCharts = hasSummaryChart
                                ? domain.Charts.Where(chart =>
                                    !string.Equals(chart.Title, summaryChart.Title, StringComparison.OrdinalIgnoreCase))
                                    .ToList()
                                : domain.Charts;
                            if (hasSummaryChart)
                            {
                                <div class="chart-grid chart-grid-feature mt-4">
                                    <article class="chart-card chart-card-feature">
                                        <h3 class="chart-title">@summaryChart.Title</h3>
                                        <svg class="metric-line-chart js-metric-line-chart"
                                             viewBox="0 0 840 360"
                                             data-chart="@summaryChart.Json"
                                             role="img"
                                             aria-label="@summaryChart.Title"></svg>
                                    </article>
                                </div>
                            }
                            if (detailCharts.Count > 0)
                            {
                                <div class="chart-grid chart-grid-scroll mt-4">
                                    @foreach (var chart in detailCharts)
                                    {
                                        <article class="chart-card">
                                            <h3 class="chart-title">@chart.Title</h3>
                                            <svg class="metric-line-chart js-metric-line-chart"
                                                 viewBox="0 0 840 360"
                                                 data-chart="@chart.Json"
                                                 role="img"
                                                 aria-label="@chart.Title"></svg>
                                        </article>
                                    }
                                </div>
                            }
                        }
                    </article>
                }
            </div>
        </div>

        <div id="derived-metrics" class="players-fusion-metrics player-detail-section">
            <div class="players-fusion-head">
                <div class="page-intro-main">
                    <p class="eyebrow">@Context.T("gameplay.derived")</p>
                    <h2 class="headline text-xl">@L("Metrik Turunan Analitika", "Derived Analytics Metrics")</h2>
                    <p class="subhead text-sm">@L("Metrik turunan disajikan per domain: ringkasan gabungan dalam batang, lalu detail tetap dalam garis agar tren dan perbandingan sama-sama jelas.", "Derived metrics are presented per domain: combined snapshots in bars, then details in lines so trends and comparisons stay clear.")</p>
                </div>
            </div>

            <div class="metric-domain-layout mt-6">
                @foreach (var domain in derivedSections)
                {
                    <article class="metric-domain-card metric-domain-card-flat">
                        <div class="metric-domain-heading">
                            <h3>@domain.Title</h3>
                            <span class="metric-domain-count">@domain.Charts.Count @L("diagram", "charts")</span>
                        </div>
                        <p class="metric-domain-intro">@domain.Description</p>
                        @if (domain.Charts.Count == 0)
                        {
                            <p class="metric-domain-empty">@L("Belum ada titik numerik untuk divisualkan pada domain ini.", "No numeric points are currently available for this domain.")</p>
                        }
                        else
                        {
                            var summaryChart = domain.Charts.FirstOrDefault(chart =>
                                chart.Title.Contains("Ringkasan Gabungan", StringComparison.OrdinalIgnoreCase) ||
                                chart.Title.Contains("Combined Snapshot", StringComparison.OrdinalIgnoreCase));
                            var hasSummaryChart = !string.IsNullOrWhiteSpace(summaryChart.Title);
                            var detailCharts = hasSummaryChart
                                ? domain.Charts.Where(chart =>
                                    !string.Equals(chart.Title, summaryChart.Title, StringComparison.OrdinalIgnoreCase))
                                    .ToList()
                                : domain.Charts;
                            if (hasSummaryChart)
                            {
                                <div class="chart-grid chart-grid-feature mt-4">
                                    <article class="chart-card chart-card-feature">
                                        <h3 class="chart-title">@summaryChart.Title</h3>
                                        <svg class="metric-line-chart js-metric-line-chart"
                                             viewBox="0 0 840 360"
                                             data-chart="@summaryChart.Json"
                                             role="img"
                                             aria-label="@summaryChart.Title"></svg>
                                    </article>
                                </div>
                            }
                            if (detailCharts.Count > 0)
                            {
                                <div class="chart-grid chart-grid-scroll mt-4">
                                    @foreach (var chart in detailCharts)
                                    {
                                        <article class="chart-card">
                                            <h3 class="chart-title">@chart.Title</h3>
                                            <svg class="metric-line-chart js-metric-line-chart"
                                                 viewBox="0 0 840 360"
                                                 data-chart="@chart.Json"
                                                 role="img"
                                                 aria-label="@chart.Title"></svg>
                                        </article>
                                    }
                                </div>
                            }
                        }
                    </article>
                }
            </div>
        </div>
    }
</section>

@section Scripts {
    <script>
        (() => {
            const chartNodes = Array.from(document.querySelectorAll(".js-metric-line-chart[data-chart]"));
            if (!chartNodes.length) {
                return;
            }

            const ns = "http://www.w3.org/2000/svg";
            const palette = [
                "#1ba784",
                "#2d7dd2",
                "#f4a84a",
                "#ef4e4e",
                "#6a5acd",
                "#00a6a6"
            ];

            const makeNode = (name, attrs = {}) => {
                const node = document.createElementNS(ns, name);
                Object.entries(attrs).forEach(([key, value]) => {
                    node.setAttribute(key, String(value));
                });
                return node;
            };

            const clearNode = (node) => {
                while (node.firstChild) {
                    node.removeChild(node.firstChild);
                }
            };

            const drawEmpty = (svg, message) => {
                clearNode(svg);
                const vb = svg.viewBox && svg.viewBox.baseVal ? svg.viewBox.baseVal : null;
                const width = vb && vb.width ? vb.width : 840;
                const height = vb && vb.height ? vb.height : 360;
                const text = makeNode("text", {
                    x: width / 2,
                    y: height / 2,
                    "text-anchor": "middle",
                    "dominant-baseline": "middle",
                    fill: "#4f6e83",
                    "font-size": "13",
                    "font-family": "Nunito, Segoe UI, sans-serif"
                });
                text.textContent = message;
                svg.appendChild(text);
            };

            const buildPath = (points) => {
                if (!points.length) {
                    return "";
                }

                let path = `M ${points[0].x} ${points[0].y}`;
                for (let index = 1; index < points.length; index += 1) {
                    path += ` L ${points[index].x} ${points[index].y}`;
                }
                return path;
            };

            const normalizeLabel = (value, index) => {
                const text = String(value ?? "")
                    .replace(/[_-]+/g, " ")
                    .replace(/\s+/g, " ")
                    .trim();

                if (text.length > 0) {
                    return text;
                }

                return `Item ${index + 1}`;
            };

            const makeUniqueLabels = (labels) => {
                const usageMap = new Map();
                return labels.map((label) => {
                    const key = String(label ?? "").toLowerCase();
                    const nextCount = (usageMap.get(key) || 0) + 1;
                    usageMap.set(key, nextCount);
                    if (nextCount === 1) {
                        return label;
                    }

                    return `${label} (${nextCount})`;
                });
            };

            const wrapAxisLabel = (label, maxCharsPerLine = 16, maxLines = 2) => {
                const compactLabel = String(label ?? "").replace(/\s+/g, " ").trim();
                if (!compactLabel.length) {
                    return ["-"];
                }

                const words = compactLabel.split(" ");
                const lines = [];
                let currentLine = "";

                words.forEach((word) => {
                    const chunks = word.length > maxCharsPerLine
                        ? word.match(new RegExp(`.{1,${maxCharsPerLine}}`, "g")) || [word]
                        : [word];

                    chunks.forEach((chunk) => {
                        const candidate = currentLine.length > 0
                            ? `${currentLine} ${chunk}`
                            : chunk;

                        if (candidate.length <= maxCharsPerLine) {
                            currentLine = candidate;
                            return;
                        }

                        if (currentLine.length > 0) {
                            lines.push(currentLine);
                        }
                        currentLine = chunk;
                    });
                });

                if (currentLine.length > 0) {
                    lines.push(currentLine);
                }

                if (lines.length <= maxLines) {
                    return lines;
                }

                const trimmedLines = lines.slice(0, maxLines);
                const lastIndex = maxLines - 1;
                const lastLine = trimmedLines[lastIndex];
                if (lastLine.length >= maxCharsPerLine - 1) {
                    trimmedLines[lastIndex] = `${lastLine.slice(0, Math.max(1, maxCharsPerLine - 1)).trim()}...`;
                } else {
                    trimmedLines[lastIndex] = `${lastLine}...`;
                }

                return trimmedLines;
            };

            const drawChart = (svg, payload) => {
                const normalizedLabels = Array.isArray(payload?.labels)
                    ? payload.labels.map((value, index) => normalizeLabel(value, index))
                    : [];
                const labels = makeUniqueLabels(normalizedLabels);
                const chartType = String(payload?.chartType ?? "line").toLowerCase();
                const series = Array.isArray(payload?.series)
                    ? payload.series
                        .map((item, index) => {
                            const values = Array.isArray(item?.values)
                                ? item.values.map((value) => {
                                    if (typeof value !== "number" || !Number.isFinite(value)) {
                                        return null;
                                    }
                                    return value;
                                })
                                : [];

                            return {
                                name: String(item?.name ?? `Series ${index + 1}`),
                                values
                            };
                        })
                        .filter((item) => item.values.some((value) => value !== null))
                    : [];

                if (!labels.length || !series.length) {
                    drawEmpty(svg, "No serial metrics available");
                    return;
                }

                const numericValues = [];
                series.forEach((item) => {
                    item.values.forEach((value) => {
                        if (value !== null) {
                            numericValues.push(value);
                        }
                    });
                });

                if (!numericValues.length) {
                    drawEmpty(svg, "No numeric points");
                    return;
                }

                clearNode(svg);

                const vb = svg.viewBox && svg.viewBox.baseVal ? svg.viewBox.baseVal : null;
                const baseWidth = vb && vb.width ? vb.width : 840;
                const height = vb && vb.height ? vb.height : 360;
                const longestLabelLength = labels.reduce((max, label) => Math.max(max, label.length), 0);
                const averageLabelLength = labels.length
                    ? labels.reduce((total, label) => total + label.length, 0) / labels.length
                    : 0;
                const hostCard = svg.closest(".chart-card");
                let width = baseWidth;
                let barLabelCharsPerLine = 16;
                let wrappedAxisLabels = [];
                if (chartType === "bar") {
                    const minPitchPerLabel = Math.min(260, Math.max(
                        124,
                        longestLabelLength * 7.1,
                        averageLabelLength * 6.6 + 42));
                    const dynamicWidth = Math.max(baseWidth, labels.length * minPitchPerLabel + 280);
                    width = dynamicWidth;
                    barLabelCharsPerLine = Math.max(11, Math.min(22, Math.round(minPitchPerLabel / 8)));
                    wrappedAxisLabels = labels.map((label) => wrapAxisLabel(label, barLabelCharsPerLine, 2));
                    svg.style.width = `${dynamicWidth}px`;
                    svg.style.maxWidth = "none";
                    hostCard?.classList.add("chart-card-hscroll");
                } else {
                    svg.style.width = "100%";
                    svg.style.maxWidth = "100%";
                    hostCard?.classList.remove("chart-card-hscroll");
                }
                svg.setAttribute("viewBox", `0 0 ${width} ${height}`);

                const legendLineHeight = 16;
                const estimateLegendRows = () => {
                    const rowMaxWidth = Math.max(180, width - 110);
                    let rowWidth = 0;
                    let rows = 1;
                    series.forEach((item) => {
                        const itemWidth = Math.max(110, item.name.length * 8 + 36);
                        if (rowWidth + itemWidth > rowMaxWidth) {
                            rows += 1;
                            rowWidth = itemWidth;
                            return;
                        }

                        rowWidth += itemWidth;
                    });

                    return rows;
                };

                const legendRows = estimateLegendRows();
                const margin = {
                    top: 16 + legendRows * legendLineHeight + 12,
                    right: chartType === "bar" ? 52 : 24,
                    bottom: chartType === "bar"
                        ? 80 + Math.max(0, (
                            wrappedAxisLabels.reduce((max, lines) => Math.max(max, lines.length), 1) - 1
                        ) * 13)
                        : 58,
                    left: 62
                };
                const plotWidth = Math.max(80, width - margin.left - margin.right);
                const plotHeight = Math.max(80, height - margin.top - margin.bottom);

                let minY = Math.min(...numericValues);
                let maxY = Math.max(...numericValues);
                const hasNegativeValues = numericValues.some((value) => value < 0);
                if (chartType === "bar") {
                    minY = Math.min(minY, 0);
                    maxY = Math.max(maxY, 0);
                    const range = Math.max(0.000001, maxY - minY);
                    const topPad = Math.max(0.5, range * 0.09);
                    maxY += topPad;
                    if (hasNegativeValues) {
                        minY -= topPad * 0.35;
                    }
                }
                if (Math.abs(maxY - minY) < 0.000001) {
                    const pad = Math.abs(maxY) < 1 ? 1 : Math.abs(maxY) * 0.1;
                    minY -= pad;
                    maxY += pad;
                }

                const clusterWidth = plotWidth / Math.max(1, labels.length);
                const xForIndex = (index) => {
                    if (chartType === "bar") {
                        return margin.left + clusterWidth * index + clusterWidth / 2;
                    }

                    if (labels.length === 1) {
                        return margin.left + plotWidth / 2;
                    }

                    return margin.left + (index * plotWidth) / (labels.length - 1);
                };

                const yForValue = (value) => (
                    margin.top + ((maxY - value) * plotHeight) / (maxY - minY)
                );
                const zeroY = yForValue(0);

                const gridTicks = 4;
                for (let tick = 0; tick <= gridTicks; tick += 1) {
                    const ratio = tick / gridTicks;
                    const y = margin.top + ratio * plotHeight;
                    const value = maxY - (maxY - minY) * ratio;

                    svg.appendChild(makeNode("line", {
                        x1: margin.left,
                        y1: y,
                        x2: margin.left + plotWidth,
                        y2: y,
                        stroke: "rgba(60, 125, 145, 0.18)",
                        "stroke-width": "1"
                    }));

                    const label = makeNode("text", {
                        x: margin.left - 8,
                        y: y + 4,
                        "text-anchor": "end",
                        fill: "#5f7f92",
                        "font-size": "12",
                        "font-family": "Nunito, Segoe UI, sans-serif"
                    });
                    label.textContent = value.toFixed(1).replace(/\.0$/, "");
                    svg.appendChild(label);
                }

                svg.appendChild(makeNode("line", {
                    x1: margin.left,
                    y1: margin.top,
                    x2: margin.left,
                    y2: margin.top + plotHeight,
                    stroke: "#9ccfd2",
                    "stroke-width": "1.4"
                }));

                svg.appendChild(makeNode("line", {
                    x1: margin.left,
                    y1: chartType === "bar" ? zeroY : margin.top + plotHeight,
                    x2: margin.left + plotWidth,
                    y2: chartType === "bar" ? zeroY : margin.top + plotHeight,
                    stroke: "#9ccfd2",
                    "stroke-width": "1.4"
                }));

                const xLabelStep = chartType === "bar"
                    ? 1
                    : Math.max(1, Math.ceil(labels.length / 6));
                labels.forEach((label, index) => {
                    const isLast = index === labels.length - 1;
                    if (!isLast && index % xLabelStep !== 0) {
                        return;
                    }

                    if (chartType === "bar") {
                        const x = xForIndex(index);
                        const y = margin.top + plotHeight + 18;
                        const labelLines = wrappedAxisLabels[index] || [label];
                        const text = makeNode("text", {
                            x,
                            y,
                            "text-anchor": "middle",
                            fill: "#5f7f92",
                            "font-size": "10.5",
                            "font-family": "Nunito, Segoe UI, sans-serif"
                        });
                        labelLines.forEach((line, lineIndex) => {
                            const tspan = makeNode("tspan", {
                                x,
                                dy: lineIndex === 0 ? 0 : 12
                            });
                            tspan.textContent = line;
                            text.appendChild(tspan);
                        });
                        if (labelLines.join(" ").replace(/\.\.\.$/, "").trim() !== label) {
                            const fullLabel = makeNode("title");
                            fullLabel.textContent = label;
                            text.appendChild(fullLabel);
                        }
                        svg.appendChild(text);
                        return;
                    }

                    const text = makeNode("text", {
                        x: xForIndex(index),
                        y: margin.top + plotHeight + 18,
                        "text-anchor": "middle",
                        fill: "#5f7f92",
                        "font-size": "11",
                        "font-family": "Nunito, Segoe UI, sans-serif"
                    });
                    text.textContent = label;
                    svg.appendChild(text);
                });

                if (chartType === "bar") {
                    const seriesCount = Math.max(1, series.length);
                    const seriesGap = seriesCount > 1
                        ? Math.max(2, Math.min(8, clusterWidth * 0.05))
                        : 0;
                    const clusterInnerWidth = Math.max(12, Math.min(220, clusterWidth * 0.72));
                    const rawBarWidth =
                        (clusterInnerWidth - seriesGap * Math.max(0, seriesCount - 1)) / seriesCount;
                    const barWidth = Math.max(4, Math.min(56, rawBarWidth));
                    const barGroupWidth = barWidth * seriesCount + seriesGap * Math.max(0, seriesCount - 1);
                    const groupOffset = Math.max(0, (clusterWidth - barGroupWidth) / 2);

                    series.forEach((item, seriesIndex) => {
                        const color = palette[seriesIndex % palette.length];
                        item.values.forEach((value, index) => {
                            if (value === null) {
                                return;
                            }

                            const x =
                                margin.left +
                                clusterWidth * index +
                                groupOffset +
                                seriesIndex * (barWidth + seriesGap);
                            const y = yForValue(value);
                            const barTop = Math.min(y, zeroY);
                            const barHeight = Math.max(1.5, Math.abs(zeroY - y));
                            svg.appendChild(makeNode("rect", {
                                x,
                                y: barTop,
                                width: barWidth,
                                height: barHeight,
                                rx: "2",
                                fill: color,
                                opacity: "0.9"
                            }));
                        });
                    });
                } else {
                    series.forEach((item, seriesIndex) => {
                        const color = palette[seriesIndex % palette.length];
                        let segment = [];

                        const flushSegment = () => {
                            if (!segment.length) {
                                return;
                            }

                            const path = buildPath(segment);
                            if (path.length) {
                                svg.appendChild(makeNode("path", {
                                    d: path,
                                    fill: "none",
                                    stroke: color,
                                    "stroke-width": "2.4",
                                    "stroke-linejoin": "round",
                                    "stroke-linecap": "round"
                                }));
                            }
                            segment = [];
                        };

                        item.values.forEach((value, index) => {
                            if (value === null) {
                                flushSegment();
                                return;
                            }

                            const point = { x: xForIndex(index), y: yForValue(value) };
                            segment.push(point);
                            svg.appendChild(makeNode("circle", {
                                cx: point.x,
                                cy: point.y,
                                r: "3",
                                fill: color,
                                stroke: "#ffffff",
                                "stroke-width": "1"
                            }));
                        });
                        flushSegment();
                    });
                }

                const legendStartX = margin.left;
                let legendX = legendStartX;
                let legendRow = 0;
                const legendYBase = 16;
                const legendMaxX = margin.left + plotWidth;
                series.forEach((item, index) => {
                    const color = palette[index % palette.length];
                    const itemWidth = Math.max(110, item.name.length * 8 + 36);
                    if (legendX + itemWidth > legendMaxX) {
                        legendRow += 1;
                        legendX = legendStartX;
                    }

                    const legendY = legendYBase + legendRow * legendLineHeight;
                    if (chartType === "bar") {
                        svg.appendChild(makeNode("rect", {
                            x: legendX,
                            y: legendY - 4.5,
                            width: "12",
                            height: "9",
                            rx: "2",
                            fill: color
                        }));
                    } else {
                        svg.appendChild(makeNode("line", {
                            x1: legendX,
                            y1: legendY,
                            x2: legendX + 14,
                            y2: legendY,
                            stroke: color,
                            "stroke-width": "2.2",
                            "stroke-linecap": "round"
                        }));
                    }

                    const label = makeNode("text", {
                        x: legendX + 18,
                        y: legendY + 4,
                        fill: "#32576e",
                        "font-size": "11",
                        "font-family": "Nunito, Segoe UI, sans-serif"
                    });
                    label.textContent = item.name;
                    svg.appendChild(label);

                    legendX += itemWidth;
                });
            };

            chartNodes.forEach((node) => {
                try {
                    const payload = JSON.parse(node.dataset.chart || "{}");
                    drawChart(node, payload);
                } catch {
                    drawEmpty(node, "Chart payload invalid");
                }
            });
        })();
    </script>
}
