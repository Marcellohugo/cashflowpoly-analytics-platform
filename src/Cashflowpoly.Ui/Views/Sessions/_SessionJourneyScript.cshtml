@model Cashflowpoly.Ui.Models.SessionDetailViewModel
@using System.Text.Json

<script>
    (() => {
        const boardTrackEl = document.getElementById("session-board-track");
        const errorEl = document.getElementById("session-journey-error");
        const syncedEl = document.getElementById("session-journey-synced");
        const insightTotalEl = document.getElementById("session-journey-insight-total");
        const insightDayTurnEl = document.getElementById("session-journey-insight-day-turn");
        const insightActorEl = document.getElementById("session-journey-insight-actor");
        const insightActionEl = document.getElementById("session-journey-insight-action");

        if (!boardTrackEl || !errorEl || !syncedEl) {
            return;
        }

        const timelineUrl = "@Url.Action("Timeline", "Sessions", new { sessionId = Model.SessionId })";
        const activeLanguage = @Html.Raw(JsonSerializer.Serialize(UiText.NormalizeLanguage(Context.Session.GetString(AuthConstants.SessionLanguageKey))));
        const browserLocale = activeLanguage === "en" ? "en-US" : "id-ID";
        const emptyMessage = @Html.Raw(JsonSerializer.Serialize(Context.T("sessions.journey.no_events")));
        const realtimeStatusTemplate = @Html.Raw(JsonSerializer.Serialize(Context.T("sessions.journey.realtime_status")));
        const realtimeNetworkMessage = @Html.Raw(JsonSerializer.Serialize(Context.T("sessions.journey.realtime_network")));
        const activityFallbackLabel = @Html.Raw(JsonSerializer.Serialize(Context.T("sessions.activity_default")));
        const dayLabel = @Html.Raw(JsonSerializer.Serialize(Context.T("sessions.day_label")));
        const turnLabel = @Html.Raw(JsonSerializer.Serialize(Context.T("sessions.turn_label")));
        const seqLabel = @Html.Raw(JsonSerializer.Serialize(Context.T("sessions.timeline_seq")));
        const actorLabels = {
            PLAYER: @Html.Raw(JsonSerializer.Serialize(Context.T("sessions.actor.player"))),
            SYSTEM: @Html.Raw(JsonSerializer.Serialize(Context.T("sessions.actor.system"))),
            INSTRUCTOR: @Html.Raw(JsonSerializer.Serialize(Context.T("sessions.actor.instructor"))),
            OTHER: @Html.Raw(JsonSerializer.Serialize(Context.T("sessions.actor.other")))
        };
        const playerLookupRaw = @Html.Raw(JsonSerializer.Serialize(Model.PlayerDisplayNames));
        const initialTimelineRaw = @Html.Raw(JsonSerializer.Serialize(Model.Timeline));
        const pollIntervalMs = 10000;
        const maxBoardNodes = 24;

        const playerLookup = Object.fromEntries(
            Object.entries(playerLookupRaw ?? {}).map(([key, value]) => [String(key).toLowerCase(), value])
        );
        let timeline = [];
        let pollingTimerId = null;
        let lastSequence = 0;

        const hasOwn = (obj, key) => Object.prototype.hasOwnProperty.call(obj, key);
        const toNumber = (value, fallback = 0) => {
            const numericValue = Number(value);
            return Number.isFinite(numericValue) ? numericValue : fallback;
        };
        const readValue = (obj, camelKey, pascalKey) => {
            if (!obj || typeof obj !== "object") {
                return undefined;
            }

            if (hasOwn(obj, camelKey)) {
                return obj[camelKey];
            }

            if (hasOwn(obj, pascalKey)) {
                return obj[pascalKey];
            }

            return undefined;
        };
        const escapeHtml = (text) =>
            String(text ?? "")
                .replaceAll("&", "&amp;")
                .replaceAll("<", "&lt;")
                .replaceAll(">", "&gt;")
                .replaceAll("\"", "&quot;")
                .replaceAll("'", "&#39;");
        const actorBucket = (actorType) => {
            const normalized = String(actorType ?? "").toUpperCase();
            return normalized === "PLAYER" || normalized === "SYSTEM" || normalized === "INSTRUCTOR"
                ? normalized
                : "OTHER";
        };
        const flowBucket = (actionType) => {
            const normalized = String(actionType ?? "").toLowerCase();
            if (normalized.startsWith("setup.")) return "setup";
            if (normalized.startsWith("day.")) return "day";
            if (normalized.startsWith("risk.")) return "risk";
            if (normalized.startsWith("loan.")) return "loan";
            if (normalized.startsWith("saving.")) return "saving";
            if (normalized.startsWith("mission.")) return "mission";
            if (normalized.includes("order")) return "order";
            return "generic";
        };
        const actorLabel = (item) => {
            const bucket = actorBucket(item.actorType);
            if (bucket === "PLAYER") {
                if (item.playerDisplayName) {
                    return item.playerDisplayName;
                }
                const lookupName = playerLookup[String(item.playerId ?? "").toLowerCase()];
                return lookupName || actorLabels.PLAYER;
            }

            if (bucket === "SYSTEM") return actorLabels.SYSTEM;
            if (bucket === "INSTRUCTOR") return actorLabels.INSTRUCTOR;
            return actorLabels.OTHER;
        };
        const actionLabel = (item) => item.flowLabel || item.actionType || activityFallbackLabel;
        const normalizeTimeline = (rawTimeline) => {
            if (!Array.isArray(rawTimeline)) {
                return [];
            }

            return rawTimeline
                .map((item) => {
                    const sequenceNumber = toNumber(readValue(item, "sequenceNumber", "SequenceNumber"), 0);
                    return {
                        timestamp: readValue(item, "timestamp", "Timestamp"),
                        sequenceNumber,
                        dayIndex: toNumber(readValue(item, "dayIndex", "DayIndex"), 0),
                        weekday: String(readValue(item, "weekday", "Weekday") ?? ""),
                        turnNumber: Math.max(1, toNumber(readValue(item, "turnNumber", "TurnNumber"), 1)),
                        actorType: String(readValue(item, "actorType", "ActorType") ?? ""),
                        playerId: readValue(item, "playerId", "PlayerId"),
                        playerDisplayName: readValue(item, "playerDisplayName", "PlayerDisplayName"),
                        actionType: String(readValue(item, "actionType", "ActionType") ?? ""),
                        flowLabel: String(readValue(item, "flowLabel", "FlowLabel") ?? ""),
                        flowDescription: String(readValue(item, "flowDescription", "FlowDescription") ?? "")
                    };
                })
                .filter((item) => item.sequenceNumber > 0)
                .sort((a, b) => {
                    if (a.sequenceNumber !== b.sequenceNumber) {
                        return a.sequenceNumber - b.sequenceNumber;
                    }

                    return String(a.timestamp ?? "").localeCompare(String(b.timestamp ?? ""));
                });
        };
        const formatDateTime = (rawValue) => {
            const dt = new Date(rawValue);
            if (Number.isNaN(dt.getTime())) {
                return "-";
            }

            return dt.toLocaleString(browserLocale, {
                day: "2-digit",
                month: "2-digit",
                year: "numeric",
                hour: "2-digit",
                minute: "2-digit",
                second: "2-digit"
            });
        };
        const clearFocusedItems = () => {
            boardTrackEl.querySelectorAll(".session-board-node.is-focused").forEach((node) => {
                node.classList.remove("is-focused");
            });
        };
        const focusBySequence = (sequenceNumber) => {
            const normalizedSeq = toNumber(sequenceNumber, 0);
            if (normalizedSeq <= 0) {
                return;
            }

            clearFocusedItems();
            const boardNode = boardTrackEl.querySelector(`.session-board-node[data-seq="${normalizedSeq}"]`);

            if (boardNode) {
                boardNode.classList.add("is-focused");
                boardNode.scrollIntoView({ behavior: "smooth", block: "nearest", inline: "center" });
            }
        };
        const bindJourneyInteractions = () => {
            boardTrackEl.querySelectorAll(".session-board-node[data-seq]").forEach((node) => {
                node.addEventListener("click", () => {
                    focusBySequence(node.getAttribute("data-seq"));
                });
            });
        };
        const setError = (message) => {
            if (!message) {
                errorEl.textContent = "";
                errorEl.classList.add("hidden");
                return;
            }

            errorEl.textContent = message;
            errorEl.classList.remove("hidden");
        };
        const mergeTimeline = (incoming) => {
            if (!Array.isArray(incoming) || incoming.length === 0) {
                return;
            }

            const map = new Map(timeline.map((item) => [item.sequenceNumber, item]));
            incoming.forEach((item) => {
                map.set(item.sequenceNumber, item);
            });
            timeline = Array.from(map.values()).sort((a, b) => a.sequenceNumber - b.sequenceNumber);
        };
        const renderJourneyBoard = () => {
            const boardEvents = timeline.slice(-maxBoardNodes);
            if (boardEvents.length === 0) {
                boardTrackEl.innerHTML = `<div class="session-journey-empty">${escapeHtml(emptyMessage)}</div>`;
                return;
            }

            boardTrackEl.innerHTML = boardEvents.map((item, index) => {
                const laneClass = index % 2 === 0 ? "lane-top" : "lane-bottom";
                const actorClass = `actor-${actorBucket(item.actorType).toLowerCase()}`;
                const flowClass = `flow-${flowBucket(item.actionType)}`;
                const dayTurnLabel = `${dayLabel} ${item.dayIndex + 1} | ${turnLabel} ${item.turnNumber}`;
                const detailLabel = item.flowDescription || activityFallbackLabel;
                return `
                    <article class="session-board-node ${laneClass} ${actorClass} ${flowClass}" data-seq="${item.sequenceNumber}">
                        <div class="session-board-node-head">
                            <span class="session-board-pin">${index + 1}</span>
                            <span class="session-board-seq">${escapeHtml(seqLabel)} ${item.sequenceNumber}</span>
                        </div>
                        <h4 class="session-board-title">${escapeHtml(actionLabel(item))}</h4>
                        <p class="session-board-subtitle">${escapeHtml(actorLabel(item))}</p>
                        <p class="session-board-meta">${escapeHtml(dayTurnLabel)} | ${escapeHtml(item.weekday || "-")}</p>
                        <p class="session-board-detail">${escapeHtml(detailLabel)}</p>
                    </article>`;
            }).join("");
        };
        const renderJourneyInsights = () => {
            if (!insightTotalEl || !insightDayTurnEl || !insightActorEl || !insightActionEl) {
                return;
            }

            if (timeline.length === 0) {
                insightTotalEl.textContent = "0";
                insightDayTurnEl.textContent = "-";
                insightActorEl.textContent = "-";
                insightActionEl.textContent = "-";
                return;
            }

            const latestItem = timeline[timeline.length - 1];
            insightTotalEl.textContent = `${timeline.length}`;
            insightDayTurnEl.textContent = `${dayLabel} ${latestItem.dayIndex + 1} | ${turnLabel} ${latestItem.turnNumber}`;
            insightActorEl.textContent = actorLabel(latestItem);
            insightActionEl.textContent = actionLabel(latestItem);
        };
        const renderAll = () => {
            renderJourneyBoard();
            renderJourneyInsights();
            bindJourneyInteractions();
            lastSequence = timeline.length > 0
                ? Math.max(...timeline.map((item) => item.sequenceNumber))
                : 0;
        };
        const syncTimeline = async () => {
            try {
                const response = await fetch(`${timelineUrl}?fromSeq=${encodeURIComponent(lastSequence)}&limit=200`, {
                    method: "GET",
                    headers: { "Accept": "application/json" }
                });

                if (!response.ok) {
                    setError(realtimeStatusTemplate.replace("{status}", `${response.status}`));
                    return;
                }

                const data = await response.json();
                const incomingTimeline = normalizeTimeline(data?.timeline);
                mergeTimeline(incomingTimeline);
                renderAll();
                setError(data?.errorMessage || "");
                syncedEl.textContent = formatDateTime(data?.lastSyncedAt ?? new Date().toISOString());
            } catch {
                setError(realtimeNetworkMessage);
            }
        };
        const startPolling = () => {
            if (pollingTimerId !== null) {
                return;
            }

            syncTimeline();
            pollingTimerId = setInterval(syncTimeline, pollIntervalMs);
        };
        const stopPolling = () => {
            if (pollingTimerId === null) {
                return;
            }

            clearInterval(pollingTimerId);
            pollingTimerId = null;
        };
        const handleVisibility = () => {
            if (document.visibilityState === "visible") {
                startPolling();
                return;
            }

            stopPolling();
        };

        timeline = normalizeTimeline(initialTimelineRaw);
        renderAll();
        document.addEventListener("visibilitychange", handleVisibility);
        handleVisibility();
    })();
</script>
